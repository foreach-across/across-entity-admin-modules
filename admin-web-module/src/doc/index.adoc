= AdminWebModule
Arne Vandamme
1.1.1.RELEASE
:toc: left
:sectanchors:
:module-version: 1.1.1.RELEASE
:module-name: AdminWebModule
:module-artifact: admin-web-module
:module-url: https://foreach.atlassian.net/wiki/display/AX/AdminWebModule
:spring-security-module-url: https://foreach.atlassian.net/wiki/display/AX/SpringSecurityModule
:bootstrap-ui-module-url: https://foreach.atlassian.net/wiki/display/AX/BootstrapUiModule

== General information

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across.modules</groupId>
			<artifactId>{module-artifact}</artifactId>
			<version>{module-version}</version>
		</dependency>
	</dependencies>
----

=== Module dependencies

.Module dependencies
|===
|Module |Type |Description

|<<integration:acrossweb>>
|required
|Provides the web infrastructure for supporting `@AdminWebController`.

|{bootstrap-ui-module-url}[BootstrapUiModule]
|required
|Required for building the basic administration UI.

|<<integration:springsecurity>>
|required
|Provides the security infrastructure.

|<<integration:application-info>>
|optional
|Sets the _admin web title_ and _remember-me_ cookie name if not set explicitly.
|===

=== Module settings

All properties start with the *adminWebModule.* prefix.

|===
|Property |Type |Description |Default

|root-path
|`String`
|Root path for all admin web controllers.  All mappings will be relative to this path.
|/admin

|dashboard
|`String`
|Path within the admin web context for the initial dashboard.
|/

|title
|`String`
|Name of the application to be shown in the administration UI.
|

|access-permissions
|`String[]`
|Set of permissions that grant access to the administration interface.
|access administration

|locale.default-locale
|`Locale`
|Default locale that should explicitly be set when accessing the administration interface if no specific locale selected.
|`Locale.US`

|locale.options
|`List<Locale>`
|List of locales that can be selected on the login page.
|`Collections.emptyList()`

|login.template
|`String`
|View template for the login page.
|th/adminweb/login

|login.rememberMe.enabled
|`Boolean`
|Should remember me be enabled (will only be the case if a key is also configured).
|`true`

|login.rememberMe.key
|`String`
|Key used for creating the remember me cookie.
|

|login.rememberMe.cookie
|`String`
|Name of the remember-me cookie.
|rm-admin-web

|login.rememberMe.tokenValiditySeconds
|`Integer`
|Number of seconds a remember me token should be valid.
|_30 days_

|===

== What's new in this version?
:numbered!:
=== 2.0.0-SNAPSHOT

* AdminWebModule now depends on {bootstrap-ui-module-url}[BootstrapUiModule]
* the login page now provides an attribute *isLoginPage* that is accessible in the global template
* added the <<page-content-structure,`PageContentStructure` with corresponding template>> to facilitate layouting admin pages

=== 1.1.1.RELEASE

* all settings are now configurable through properties with Spring configuration metadata support
* login template now uses the `isRememberMeEnabled` attribute to determine if the remember-me checkbox should be shown
** this is a *breaking change* for custom templates
* a <<developer-tools,Developer tools>> menu section gets created if development mode is active

=== 1.1.0.RELEASE
Initial public release available on http://search.maven.org/[Maven central].

== About the AdminWebModule
{module-name} provides infrastructure for building an secured administration section in your site.
All `@AdminWebController` beans will be mapped behind the admin web root path and will have the security rules applied.

Unless otherwise specified, the default admin web template will be applied for those controllers.
The default template is built on Bootstrap and JQuery and builds a menu structure that controllers can hook into via the `AdminMenuEvent`.

=== Remember me configuration
You can easily enable remember me support for the administration ui by setting the correct properties.  By default
the `TokenBasedRememberMeServices` are used, meaning the user password is encoded into the cookie value.  When using a
local memory database during development this can be unhandy when users get reinstalled upon application start.  If
the user password is also encoded using a random encoder (the default when using the `UserModule`) the remember me
cookies will not work after a restart.  The solution for this to configure either a `NoOpPasswordEncoder.getInstance()`
or a fixed password encoder in local development mode.

== Integration with other modules

[[integration:acrossweb]]
=== AcrossWebModule
Admin web creates its own `PrefixingRequestMappingHandlerMapping` that picks up all `@AdminWebController` and will prefix all request mappings with the root path of the admin web module.

Provide an `AdminWebConfigurerAdapter` if you want to register interceptors that should only be applied to the admin web controllers.

[[integration:springsecurity]]
=== SpringSecurityModule
By default `AdminWebModule` adds a `SpringWebSecurityConfigurerAdapter` with default rules for all requests under the admin web root.
If you wish to modify the default security rules, you must provide your own `SpringWebSecurityConfigurerAdapter` that is positioned before the default `AdminWebSecurityConfiguration` instance.

If you create a new `SpringWebSecurityConfigurerAdapater` you will need to scope it correctly to the admin web root path and provide all rules including things like login/logout and remember me.
If you are interested more in extending the default configuration, you can extend `AdminWebSecurityConfiguration` and override the `customizeAdminWebSecurity` adapter method.

.Example of disabling security headers on admin web
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * Create a custom security configurer that extends from the
 * default AdminWebSecurityConfiguration but disables all
 * security headers.
 *
 * The @OrderInModule annotation will ensure that this
 * configurer will be positioned before the default configuration
 * once we add it to the AdminWebModule context.
 */
@Configuration
@OrderInModule(Ordered.HIGHEST_PRECEDENCE)
public class DisableAdminWebSecurityHeaders extends AdminWebSecurityConfiguration
{
	@Override
	protected void customizeAdminWebSecurity( HttpSecurity http ) throws Exception {
		http.headers().disable();
	}
}

...

// Add the custom security configuration to the AdminWebModule
AdminWebModule adminWebModule = new AdminWebModule();
adminWebModule.addApplicationContextConfigurer( DisableAdminWebSecurityHeaders.class );
----

[[integration:application-info]]
=== ApplicationInfoModule
If the `ApplicationInfoModule` is present in the context, the configured application information will be used
to set the default remember-me cookie name (based on the `ApplicationInfo.getApplicationId()`) and application title for
 the administration interface (based on the `ApplicationInfo.getApplicationName()` property).use DebugWebConfigurerAdapter to add interceptors only to debug web

== Registering additional interceptors
Additional interceptors for admin controllers can easily be registered by providing an `AdminWebConfigurerAdapter` bean.

== Permissions
By default, access to the administration interface is restricted to users having the *access administration* permission.
The allowed permissions can be specified by setting the *adminWebModule.access-permissions* property.

== Customizing the look and feel
=== Default template
All admin web controllers will use a default template named *adminWeb*.
You can customize which template to use by modifying the `WebTemplateRegistry` bean named *adminWebTemplateRegistry*.
You can either change the default template or simply replace the instance registered as *adminWeb*.

WARNING: The login page uses the same default template as all other admin web controllers.
This means the template should take both authorized and non-authorized authentications into account.

=== Login page
The default login page can be customized by setting the property *adminWebModule.login.template* to the Thymeleaf template you wish to render.
The login controller provides the following model attributes that can be used to customize the template:

|===

|Attribute |Type |Description

|*isLoginPage*
|`Boolean`
|Always `true`.
This attribute can be used in the wrapping template to determine if the login page is being requested.

|*isRememberMeEnabled*
|`Boolean`
|Can be used to determine if a remember me checkbox should be rendered.

|*localeOptions*
|`List<Locale>`
|Lists the different locale options that should be offered on the login page.

|===

== Building an administration UI
=== Registering admin controllers
{module-name} will scan for all beans annoted with `@AdminWebController`.
This is a replacement for the default `@Controller` annotation and marks the beans as controllers that should run under the {module-name} root path.

All request mappings that the controller declares will be prefixed with the admin root path, and will be secured behind it.
The default admin web template will be applied to the controller unless it explicitly declares a `@Template` annotation.

NOTE: `@AdminWebController` also declared a Spring condition.
Beans annotated with `@AdminWebController` will only get created if {module-name} is present.

The following code snippet illustrates creating a simple admin controller:

.Example creating a custom admin web controller
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@AdminWebController
@RequestMapping("/demo")
public class DemoAdminWebController
{
	@RequestMapping("/page")
	public String renderPage( Model model ) {
	    model.addAttribute( "message", "Hello!" );
	    return "th/myModule/admin/page";
	}
}
----

With the default settings, the controller in the example would be available as _/admin/demo/page.

=== Linking to other admin controllers
Because admin controllers have no knowledge of the base prefix, care should be taken to use the `WebAppPathResolver` with the correct prefix for generating the right links.

There are 3 ways to do this:

* using the *adminWeb* prefix in the `WebAppPathResolver` bean: `webapp.path("@adminWeb:/demo/page")`
* using the *adminWeb* prefix directly in any Thymeleaf url: `th:href="@{@adminWeb:/demo/page}"`
* using the `AdminWeb` bean to generate paths or redirect: `adminWeb.redirect("/demo/page")`

NOTE: {module-name} registers the *adminWeb* link prefix that represents the admin web root path.

=== Adding a page to the main nav section
If you want to add a page to the main navigation section of admin web, you can do so by simply registering it in the `AdminMenu`.
The easiest way to do so is by intercepting the `AdminMenuEvent`.

.Example creating a custom admin web controller
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Event
public void registerMenuItem( AdminMenuEvent adminMenuEvent ) {
	adminMenuEvent.builder()
	              .group( "/group", "Demo pages" ).and()
	              .item( "/group/page", "My demo page", "/demo/page" );
}
----

NOTE: Relative urls added to the `AdminMenuEvent` will be considered admin web relative, and will get prefixed with the admin web root path.
If you want to avoid this, either use absolute urls, add a specific prefix or begin them with an exclamation mark (!).

[[page-content-structure]]
=== Default page structures
When creating an admin web page you can use the `PageContentStructure` to help you build a reliable layout.
The `PageContentStructure` is a `ViewElement` that represents the different sections on a page:

* _header_ with the _page title_ and optionally _page title sub text_
* _feedback_ section below the header but before the other page content
* _nav_ section meant for the in-page navigation (for example tabs)
* _body_ section holding the main content
* _footer_ section at the bottom

`PageContentStructure` can be autowired as a request-scoped bean.
If you then use the default template `PageContentStructure.TEMPLATE` this will render the entire page.
This requires you to add all content as `ViewElement` components, but of course you can still specify one or more of the `ViewElement` values to use a custom template for rendering.

.Example using the default page structure
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Autowired
private PageContentStructure page;

@RequestMapping("/page")
public String pageContent( ViewElementBuilderContext builderContext ) {

    // Render a tab layout
    page.setRenderAsTabs( true );

    // Manually create a menu structure
    Menu menu = new PathBasedMenuBuilder()
        .item( "/one", "One", "#" ).order( 1 ).and()
        .group( "/advanced", "Advanced settings" )
        .order( 2 )
        .attribute( "html:class", "pull-right" )
        .attribute( NavComponentBuilder.ATTR_ICON_ONLY, true )
        .and()
        .item( "/advanced/trash", "Move to trash", "#" )
        .attribute( NavComponentBuilder.ATTR_ICON, new GlyphIcon( GlyphIcon.TRASH ) )
        .and()
        .build();
    menu.sort();

    page.setPageTitle( "Some page title..." );
    page.addToPageTitleSubText( new GlyphIcon( GlyphIcon.ALERT ) );

    // Convert our menu to a tab nav
    page.addToNav( bootstrapUiComponentFactory.nav( menu ).tabs().build( builderContext ) );
    page.addToFeedback(
        bootstrapUiFactory.alert().danger().dismissible().text( "Hello!" )
                            .build( builderContext )
    );

    page.addChild( TextViewElement.text( "Some body content..." ) );

    return PageContentStructure.TEMPLATE;
}
----

If you do not want to use the request scoped `PageContentStructure`, you can always manually create an instance.
For the default template to work, it requires the structure to be available on the model as the default *pageContentStructure* attribute.

.Example using a custom page structure
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@RequestMapping("/page")
public String pageContent( @ModelAttribute PageContentStructure page ) {
    ...

    return PageContentStructure.TEMPLATE;
}
----

Instead of using the default template `PageContentStructure.TEMPLATE`, you can always use your own page template and simply render some of the `ViewElement` properties of the `PageContentStructure` where and when you want them.

[[developer-tools]]
=== Developer tools section
If development mode is active on the Across context, a menu group titled *Developer tools* will get created.
This allows other modules to register development only resources in the administration UI.

The path of the menu group is */ax/developer*.

.Example development controller that only gets created if development mode is active
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@AdminWebController
@ConditionalOnDevelopmentMode
@RequiredArgsConstructor
public class DevToolsController
{
	private final PageContentStructure pageContentStructure;

	@Event
	void registerDeveloperToolsItem( AdminMenuEvent menuEvent ) {
		menuEvent.builder().item( DeveloperToolsMenuRegistrar.PATH + "/test", "Test controller" );
	}

	@GetMapping("/ax/developer/test")
	public String test() {
		pageContentStructure.setPageTitle( "Test developer tools page..." );
		return PageContentStructure.TEMPLATE;
	}
}
----