== Customizing generated Entity views
The following section gives an overview of common custimizations for generated entity views.

=== Changing entity names, property names or other labels
Labels are resolved using a message code hierarchy.
Simply define one or more message sources specifying the properties you want.
Unless custom `EntityMessageCodeResolver` instances are being used, message codes are generated as follows:

|===
|Message code|Description

| enums.*EnumName*.*EnumValue*
| Message code for a single enum value label. +
Example: _enums.Numbers.ONE_

| *EntityPrefix*.name.singular
| Label for an entity in singular form, for use outside or at the beginning of a sentence. +
Example: _UserModule.entities.user.name.singular_

| *EntityPrefix*.name.plural
| Label for an entity in plural form, for use outside or at the beginning of a sentence. +
Example: _UserModule.entities.user.name.plural_

| *EntityPrefix*.name.singular.inline
| Label for an entity in singular form, for use within a sentence. If not explicitly specified, the label is
generated based by lower-casing the non-inline version. +
Example: _UserModule.entities.user.name.singular.inline_

| *EntityPrefix*.name.plural.inline
| Label for an entity in plural form, for use within a sentence.  If not explicitly specified, the label is
 generated based by lower-casing the non-inline version. +
Example: _UserModule.entities.user.name.plural.inline_

| *EntityPrefix*.properties.*propertyName*
| Label for a single entity property. +
Example: _UserModule.entities.user.properties.username_

| *EntityPrefix*.properties.*propertyName*[description]
| Description text for a property.  If not empty this will be rendered in a help block on forms. +
Example: _UserModule.entities.user.properties.username[description]_

| *EntityPrefix*.properties.*propertyName*[placeholder]
| Placeholder text for a property.  Will be used for certain controle like textbox. +
Example: _UserModule.entities.user.properties.username[placeholder]_

| *EntityPrefix*.validation.*validatorKey*
| Description text for a validation error message.  Optionally can be suffixed with the specific property name. +
Example: _UserModule.entities.user.validation.NotBlank_,  _UserModule.entities.user.validation.alreadyExists.username_

| *EntityPrefix*.adminMenu.general
| Name of the _General_ tab.
Usually the first tab that is also opened when creating a new entity.

| *EntityPrefix*.adminMenu.*associationName*
| Name of the tab for that association. +
Example: _UserModule.entities.group.adminMenu.user.groups_

| *EntityPrefix*.actions.*actionName*
| Name of the actions, usually the buttons or links on a page.
Often you just want to replace these on a global level. +
Example: _EntityModule.entities.actions.save_, _UserModule.entities.group.actions.cancel_

| *EntityPrefix*.pageTitle.*pageName*
| Title of the page.
Supports <<message-code-parameters,message code parameters>>. +
Example: _UserModule.entities.user.pageTitle.update=Updating {1}: {2}_

| *EntityPrefix*.feedback.*feedbackType*
| Feedback message shown for the given feedback type. +
Example: _UserModule.entities.user.feedback.validationErrors_

|===

* _Entity_ codes are camel cased, eg. `CarBrand` would become *carBrand*
* EntityPrefix: ModuleName.entities.entityName, or EntityModule.entities.entityName or simply entityName
* Hierarchical lookups: entity can be removed, module can be replaced by EntityModule

[[message-code-parameters]]
.Message code parameters
Some message codes support parameters, if so, the following could be available:

* {0}: entity name
* {1}: entity name inline
* {2}: label of the entity being modified (if known)

=== Specifying a custom template

Every default view uses a specific (Thymeleaf) template that renders the `ViewElement` list created by the view.
If you want control over the rendering through a separate template you can specify a different template using the `template()` method on the `EntityViewFactoryBuilder`.

=== EntityViewProcessor

Modifying a default view can be done by registerin an `EntityViewProcessor` for that view.
This API allows you to modify the `ViewElement` collection that should be generated.
This is a useful hook to add for example custom form elements that you wish to add and process.
If can also be used to reorganize the layout of the form from backend code using the `ContainerViewElementUtils`.

=== Using a custom EntityViewFactory

Full control can be done by registering a custom `EntityViewFactory` implementation.

[[entity-list-view-custom-filter]]
=== Adding a custom filter to a list view

A filter on a list view usually consists of 2 parts:

* an `EntityViewProcessor` that provides the filtering options on the list view
* a custom `EntityListViewPageFetcher` that supports the filtering options when fetching the entities
** a custom form is usually added to the `EntityViewCommand.setExtensions()` for both postback and optional validation

The `EntityListViewFactoryBuilder` provides a `filter()` method that will register both parts if you component implements both interfaces.

*Custom filter example*

The following code illustrates adding a simple filter to a view.
The filter uses a separate repository method to lookup entities by name.
The filter options are added as a form on top of the list view, the form in this case rendered via a custom Thymeleaf template.

.Implementation of a single class that holds all filter logic
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
private static class GroupFilteringProcessor extends WebViewProcessorAdapter<EntityListView> implements EntityListViewPageFetcher<WebViewCreationContext>
{
	@Autowired
	private GroupRepository groupRepository;

	@Override
	protected void registerCommandExtensions( EntityViewCommand command ) {
		command.addExtensions( "filter", "" );
	}

	@Override
	protected void modifyViewElements( ContainerViewElement elements ) {
		// move the original actions
		Optional<ContainerViewElement> header = find( elements, "entityForm-header",
		                                              ContainerViewElement.class );
		header.ifPresent(
				h -> {
					Optional<NodeViewElement> actions
							= find( h, "entityForm-header-actions", NodeViewElement.class );
					actions.ifPresent( a -> a.addCssClass( "pull-right" ) );

					h.addChild( new TemplateViewElement( "th/entityModuleTest/group :: filterForm" ) );
				}
		);
	}

	@Override
	public Page fetchPage( WebViewCreationContext viewCreationContext, Pageable pageable, EntityView model ) {
		EntityViewRequest request = model.getAttribute( "viewRequest" );

		String filter = (String) request.getExtensions().get( "filter" );
		if ( !StringUtils.isBlank( filter ) ) {
			return groupRepository.findByNameContaining( filter, pageable );
		}

		return groupRepository.findAll( pageable );
	}
}
----

.Custom Thymeleaf template that builds the form
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
<fragments xmlns:th="http://www.w3.org/1999/xhtml">
    <div class="list-header form form-inline" th:fragment="filterForm">
        <div class="form-group">
            <label for="group-name-filter">Filter by name:</label>
            <input id="group-name-filter" name="extensions[filter]" th:value="${viewRequest.extensions['filter']}" type="text" class="form-control" />
        </div>
        <input type="submit" class="btn btn-default" value="Apply filter" />
    </div>
</fragments>
----

.Registration of the custom filter on the list view
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
entities.withType( Group.class )
        .listView( lvb -> lvb
            .entityQueryFilter( false )           // optional - disable the previously activated entity query filter
            .filter( groupFilteringProcessor() )  // register the custom filter
		);
----

=== Selecting properties
`EntityPropertySelector`, incremental builders, keep current, select all, select all without default filter, exclude

=== Fieldset properties
A fieldset is a visual grouping of other properties, inside a block that has a title (legend) and optional description.
Fieldsets are rendered as a `FieldsetFormElement`.
You can postprocess a group of `ViewElement` instances and move them manually to a `FieldsetFormElement`, or you can set a fieldset as the `ViewElementMode` for a property.

In the latter, because a fieldset is a collection of other properties, you will need to specify which properties make up the fieldset.
Specifying the properties of fieldset is done by setting the `EntityAttributes.FIELDSET_PROPERTY_SELECTOR` to a valid `EntityPropertySelector`.

The following is an example of manually adding a fieldset property to a form, and moving some properties to it:
[source,java,indent=0]
[subs="verbatim,attributes"]
----
entities.withType( WebPage.class )
        .createOrUpdateFormView( fvb -> fvb
                /**
                 * First create a new property that is a fieldset
                 * of the existing url and urlGenerated properties.
                 * We add this property only to the scope of the
                 * create or update form view.
                 */
                .properties( props -> props
                        .property( "url-settings" )
                        .displayName( "URL settings" )
                        .viewElementType( ViewElementMode.FORM_WRITE, BootstrapUiElements.FIELDSET )
                        .attribute(
                                EntityAttributes.FIELDSET_PROPERTY_SELECTOR,
                                EntityPropertySelector.of( "url", "urlGenerated" )
                        )
                )
                /**
                 * Because url and urlGenerated are direct members
                 * of WebPage, we need to ensure they are not rendered
                 * directly anymore, so we remove them from the form view.
                 * The new url-settings property will be selected by default
                 * and in turn will render the url and urlGenerated properties.
                 *
                 * If we were to configure the url-settings property as hidden,
                 * we would have to explicitly include it in the form view as well.
                 * That would probably be a preferred approach if we have defined
                 * url-settings in the global property registry for WebPage.
                 */
                .showProperties( "*", "~url", "~urlGenerated" )
        )
----

NOTE: Properties mapped to an `@Embedded` type will automatically be mapped as a fieldset type.

=== Customizing entity validation

By default annotation validation is performed on all entities.
Customizing validation can be done by simply specifying a `Validator` bean that supports the specific entity type.
You can use the `EntityValidatorSupport` as a base class to extend the default annotation based entity validation.

If more than one `Validator` could be applied, you will manually have to set the `Validator.class` attribute on the `EntityConfiguration` to the correct one.

=== Customizing *VALUE* mode elements

The `ViewElementMode.VALUE` and `ViewElementMode.LIST_VALUE` are the defaults to provide the output of a property for readonly views.
Unless a specific `ViewElement` is configured, this will always be a `String` output of the property.
By default the *mvcConversionService* will be used to convert the property value if no type specific builder is provided.

Apart from providing a custom `ViewElement` you can also modify the rendered output by providing attributes on the `EntityPropertyDescriptor`.
If you provide a `org.springframework.format.Printer.class` attribute, that implementation will be used for printing the text value.
Alternatively you can provide a `java.text.Format.class` attribute to be used.
Note that most default `Format` implementations are not thread-safe, in that case you should wrap them in a `SynchronizedFormat` instance.

All standard view elements will use the `Printer` or `Format` attribute if one of them is present, instead of the default.
A `Printer` attribute takes precedence over a `Format`.

=== Customizing textbox elements

`TextboxFormElement.Type` can be set as an attribute on the `EntityPropertyDescriptor`.
If set and the property is generated as a `TextboxFormElement`, that type will be used.

You can add default post processors to the `TextboxFormElementBuilderFactory` to customize the autodetection.

=== Customizing numeric elements

By default all `Number` type properties will result in a `NumericFormElement` being used which is rendered as a textbox.
The behavior can be customized by providing a `NumericFormElementConfiguration`.
A default configuration will only be created for properties annotated with a Spring `@NumberFormat` for type `CURRENCY` or `PERCENT`, if no `NumericFormElementConfiguration.class` or `NumericFormElementConfiguration.Format.class` attribute is present.

If a `NumericFormElementConfiguration` is present a more advanced javascript control will be used in the front-end for value input.
The same configuration will also be used for rendering the *VALUE* mode elements, formatting the output according to the properties configured.

.Manually configuring percent
Put a format attribute with value `PERCENT` on the `EntityPropertyDescriptor`.
This will create a locale specific percentage format with 2 decimals (unless the property type is integer).
Alternatively use the static `NumericFormElementConfiguration.percent()` factory method to quickly create a localizable format suitable for percentages.

NOTE: If you use Spring number format for `PERCENT` then 1 is expected to match 100%.
If you manually create a `NumericFormElementConfiguration` it expects 100 to match with 100%.
You can modify this behavior by setting the `multiplier` property on the configuration.

.Manually configuring currency
The easiest way to configure a currency is to set a `Currency.class` attribute for the property.
In that case a locale specific format for that currency will be created.
Alternatively the same options as for percentages can be used and there is a `NumericFormElementConfiguration.currency()` factory method available.

=== Customizing datetime picker elements

By default all `Date` properties will result in a `DateTimeFormElement` which is rendered as a date time picker.
The form element can be customized through the `DateTimeFormElementConfiguration` class.
The default configuration is determined based on the presence of `@Temporal` annotations on the property.
The date picker supports 3 major modes: *date*, *time* and *timestamp* (date + time) with minutes being the maximum resolution.
The presence of `@Past` and `@Future` validation annotations will additionally restrict the dates that are selectable.

A specific date picker format can easily be specified by putting a `DateTimeFormElementConfiguration.Format` attribute.
Advanced customization can be done by setting a complete `DateTimeFormElementConfiguration` as attribute.
Dynamic configuration (for example setting the first selectable date relative to the current date) can only be done by specifying a `DateTimeFormElementBuilder` manually and adding a custom post processor that modifies the `DateTimeFormElementConfiguration`.
A `DateTimeFormElementConfiguration` is always duplicated when creating an element so it is safe for post processors to modify the instance.

.Using dates with `TemporalType.TIME` and JPA
A property of type `java.util.Date` but annotated with `@Temporal(TemporalType.TIME)` will result in only time selection being available (hours and minutes).
However the `@Temporal` annotation also influences how JPA will persist the data type.
If your type was created as a timestamp in the database schema, this might result in conversion errors.
With Hibernate you can resolve this by additionally specifying a `@Type` annotation forcing the type to be persisted as timestamp.

.Example of a required time property that is written as a date relative to start of epoch time in the database
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@NotNull
@Column(name = "arrival_time")
@Temporal(TemporalType.TIME)
@Type( type = "timestamp")
private Date arrivalTime;
----
